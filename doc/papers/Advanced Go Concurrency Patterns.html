
<!DOCTYPE html>
<html>
  <head>
    <title>Advanced Go Concurrency Patterns</title>
    <meta charset='utf-8'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='/static/slides.js'></script>

    

    <script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Advanced Go Concurrency Patterns</h1>
        
        
        
          <div class="presenter">
            
  
  <p>
    Sameer Ajmani
  </p>
  

  
  <p>
    Google
  </p>
  

          </div>
        
      </article>

  
  
      <article >
      
        <h3>Video</h3>
        
  
  <p>
    This talk was presented at Google I/O in May 2013.
  </p>
  
<p class="link"><a href="https://www.youtube.com/watch?v=QDDwwePbDtw" target="_blank">Watch the talk on YouTube</a></p>
      
      <span class="pagenumber">2</span>
      </article>
  
  
  
      <article >
      
        <h3>Get ready</h3>
        
<div class="image">
  <img src="advconc/gopherswim.jpg" height="400" width="400">
</div>

      
      <span class="pagenumber">3</span>
      </article>
  
  
  
      <article >
      
        <h3>Go supports concurrency</h3>
        
  
  <p>
    In the language and runtime, not a library.
  </p>
  

  
  <p>
    This changes how you structure your programs.
  </p>
  

      
      <span class="pagenumber">4</span>
      </article>
  
  
  
      <article >
      
        <h3>Goroutines and Channels</h3>
        
  
  <p>
    Goroutines are independently executing functions in the same address space.
  </p>
  

  
  <div class="code"><pre>go f()
go g(1, 2)</pre></div>
  

  
  <p>
    Channels are typed values that allow goroutines to synchronize and exchange information.
  </p>
  

  
  <div class="code"><pre>c := make(chan int)
go func() { c &lt;- 3 }()
n := &lt;-c</pre></div>
  

  
  <p>
    For more on the basics, watch <a href="http://talks.golang.org/2012/concurrency.slide#1" target="_blank">Go Concurrency Patterns (Pike, 2012)</a>.
  </p>
  

      
      <span class="pagenumber">5</span>
      </article>
  
  
  
      <article >
      
        <h3>Example: ping-pong</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>// &#43;build OMIT

package main

import (
	&#34;fmt&#34;
	&#34;time&#34;
)

</span></pre>

<pre><span num="11">type Ball struct{ hits int }</span>
<span num="12"></span>
<span num="13">func main() {</span>
<span num="14">    table := make(chan *Ball)</span>
<span num="15">    go player(&#34;ping&#34;, table)</span>
<span num="16">    go player(&#34;pong&#34;, table)</span>
<span num="17"></span>
<span num="18">    table &lt;- new(Ball) // game on; toss the ball</span>
<span num="19">    time.Sleep(1 * time.Second)</span>
<span num="20">    &lt;-table // game over; grab the ball</span>
<span num="21">}</span>
<span num="22"></span>
<span num="23">func player(name string, table chan *Ball) {</span>
<span num="24">    for {</span>
<span num="25">        ball := &lt;-table</span>
<span num="26">        ball.hits&#43;&#43;</span>
<span num="27">        fmt.Println(name, ball.hits)</span>
<span num="28">        time.Sleep(100 * time.Millisecond)</span>
<span num="29">        table &lt;- ball</span>
<span num="30">    }</span>
<span num="31">}</span>
</pre>


</div>

      
      <span class="pagenumber">6</span>
      </article>
  
  
  
      <article >
      
        <h3>Deadlock detection</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>// &#43;build OMIT

package main

import (
	&#34;fmt&#34;
	&#34;time&#34;
)

</span></pre>

<pre><span num="11">type Ball struct{ hits int }</span>
<span num="12"></span>
<span num="13">func main() {</span>
<span num="14">    table := make(chan *Ball)</span>
<span num="15">    go player(&#34;ping&#34;, table)</span>
<span num="16">    go player(&#34;pong&#34;, table)</span>
<span num="17"></span>
<span num="18">    <b>// table &lt;- new(Ball) // game on; toss the ball</b></span>
<span num="19">    time.Sleep(1 * time.Second)</span>
<span num="20">    &lt;-table // game over; grab the ball</span>
<span num="21">}</span>
<span num="22"></span>
<span num="23">func player(name string, table chan *Ball) {</span>
<span num="24">    for {</span>
<span num="25">        ball := &lt;-table</span>
<span num="26">        ball.hits&#43;&#43;</span>
<span num="27">        fmt.Println(name, ball.hits)</span>
<span num="28">        time.Sleep(100 * time.Millisecond)</span>
<span num="29">        table &lt;- ball</span>
<span num="30">    }</span>
<span num="31">}</span>
</pre>


</div>

      
      <span class="pagenumber">7</span>
      </article>
  
  
  
      <article >
      
        <h3>Panic dumps the stacks</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>// &#43;build OMIT

package main

import (
	&#34;fmt&#34;
	&#34;time&#34;
)

</span></pre>

<pre><span num="11">type Ball struct{ hits int }</span>
<span num="12"></span>
<span num="13">func main() {</span>
<span num="14">    table := make(chan *Ball)</span>
<span num="15">    go player(&#34;ping&#34;, table)</span>
<span num="16">    go player(&#34;pong&#34;, table)</span>
<span num="17"></span>
<span num="18">    table &lt;- new(Ball) // game on; toss the ball</span>
<span num="19">    time.Sleep(1 * time.Second)</span>
<span num="20">    &lt;-table // game over; grab the ball</span>
<span num="21"></span>
<span num="22">    <b>panic(&#34;show me the stacks&#34;)</b></span>
<span num="23">}</span>
<span num="24"></span>
<span num="25">func player(name string, table chan *Ball) {</span>
<span num="26">    for {</span>
<span num="27">        ball := &lt;-table</span>
<span num="28">        ball.hits&#43;&#43;</span>
<span num="29">        fmt.Println(name, ball.hits)</span>
<span num="30">        time.Sleep(100 * time.Millisecond)</span>
<span num="31">        table &lt;- ball</span>
<span num="32">    }</span>
<span num="33">}</span>
</pre>


</div>

      
      <span class="pagenumber">8</span>
      </article>
  
  
  
      <article >
      
        <h3>It&#39;s easy to go, but how to stop?</h3>
        
  
  <p>
    Long-lived programs need to clean up.
  </p>
  

  
  <p>
    Let&#39;s look at how to write programs that handle communication, periodic events, and cancellation.
  </p>
  

  
  <p>
    The core is Go&#39;s <code>select</code> statement: like a <code>switch</code>, but the decision is made based on the ability to communicate.
  </p>
  

  
  <div class="code"><pre>select {
case xc &lt;- x:
    // sent x on xc
case y := &lt;-yc:
    // received y from yc
}</pre></div>
  

      
      <span class="pagenumber">9</span>
      </article>
  
  
  
      <article >
      
        <h3>Example: feed reader</h3>
        
  
  <p>
    My favorite feed reader disappeared.  I need a new one.
  </p>
  

  
  <p>
    Why not write one?
  </p>
  

  
  <p>
    Where do we start?
  </p>
  

      
      <span class="pagenumber">10</span>
      </article>
  
  
  
      <article >
      
        <h3>Find an RSS client</h3>
        
  
  <p>
    Searching <a href="http://godoc.org" target="_blank">godoc.org</a> for <b>&#34;rss&#34;</b> turns up several hits, including one that provides:
  </p>
  

  
  <div class="code"><pre>// Fetch fetches Items for uri and returns the time when the next
// fetch should be attempted.  On failure, Fetch returns an error.
func Fetch(uri string) (items []Item, next time.Time, err error)

type Item struct{
    Title, Channel, GUID string // a subset of RSS fields
}</pre></div>
  

  
  <p>
    But I want a stream:
  </p>
  

  
  <div class="code"><pre>&lt;-chan Item</pre></div>
  

  
  <p>
    And I want multiple subscriptions.
  </p>
  

      
      <span class="pagenumber">11</span>
      </article>
  
  
  
      <article >
      
        <h3>Here&#39;s what we have</h3>
        
  
  <div class="code"><pre>type Fetcher interface {
    Fetch() (items []Item, next time.Time, err error)
}

func Fetch(domain string) Fetcher {...} // fetches Items from domain</pre></div>
  

      
      <span class="pagenumber">12</span>
      </article>
  
  
  
      <article >
      
        <h3>Here&#39;s what we want</h3>
        
  
  <div class="code"><pre>type Subscription interface {
    Updates() &lt;-chan Item // stream of Items
    Close() error         // shuts down the stream
}

func Subscribe(fetcher Fetcher) Subscription {...} // converts Fetches to a stream

func Merge(subs ...Subscription) Subscription {...} // merges several streams</pre></div>
  

      
      <span class="pagenumber">13</span>
      </article>
  
  
  
      <article >
      
        <h3>Example</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>// &#43;build OMIT

// fakemain runs the Subscribe example with a fake RSS fetcher.
package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

// STARTITEM OMIT
// An Item is a stripped-down RSS item.
type Item struct{ Title, Channel, GUID string }

// STOPITEM OMIT

// STARTFETCHER OMIT
// A Fetcher fetches Items and returns the time when the next fetch should be
// attempted.  On failure, Fetch returns a non-nil error.
type Fetcher interface {
	Fetch() (items []Item, next time.Time, err error)
}

// STOPFETCHER OMIT

// STARTSUBSCRIPTION OMIT
// A Subscription delivers Items over a channel.  Close cancels the
// subscription, closes the Updates channel, and returns the last fetch error,
// if any.
type Subscription interface {
	Updates() &lt;-chan Item
	Close() error
}

// STOPSUBSCRIPTION OMIT

// STARTSUBSCRIBE OMIT
// Subscribe returns a new Subscription that uses fetcher to fetch Items.
func Subscribe(fetcher Fetcher) Subscription {
	s := &amp;sub{
		fetcher: fetcher,
		updates: make(chan Item),       // for Updates
		closing: make(chan chan error), // for Close
	}
	go s.loop()
	return s
}

// STOPSUBSCRIBE OMIT

// sub implements the Subscription interface.
type sub struct {
	fetcher Fetcher         // fetches items
	updates chan Item       // sends items to the user
	closing chan chan error // for Close
}

// STARTUPDATES OMIT
func (s *sub) Updates() &lt;-chan Item {
	return s.updates
}

// STOPUPDATES OMIT

// STARTCLOSE OMIT
// STARTCLOSESIG OMIT
func (s *sub) Close() error {
	// STOPCLOSESIG OMIT
	errc := make(chan error)
	s.closing &lt;- errc // HLchan
	return &lt;-errc     // HLchan
}

// STOPCLOSE OMIT

// loopCloseOnly is a version of loop that includes only the logic
// that handles Close.
func (s *sub) loopCloseOnly() {
	// STARTCLOSEONLY OMIT
	var err error // set when Fetch fails
	for {
		select {
		case errc := &lt;-s.closing: // HLchan
			errc &lt;- err      // HLchan
			close(s.updates) // tells receiver we&#39;re done
			return
		}
	}
	// STOPCLOSEONLY OMIT
}

// loopFetchOnly is a version of loop that includes only the logic
// that calls Fetch.
func (s *sub) loopFetchOnly() {
	// STARTFETCHONLY OMIT
	var pending []Item // appended by fetch; consumed by send
	var next time.Time // initially January 1, year 0
	var err error
	for {
		var fetchDelay time.Duration // initally 0 (no delay)
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		startFetch := time.After(fetchDelay)

		select {
		case &lt;-startFetch:
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch()
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			pending = append(pending, fetched...)
		}
	}
	// STOPFETCHONLY OMIT
}

// loopSendOnly is a version of loop that includes only the logic for
// sending items to s.updates.
func (s *sub) loopSendOnly() {
	// STARTSENDONLY OMIT
	var pending []Item // appended by fetch; consumed by send
	for {
		var first Item
		var updates chan Item // HLupdates
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case // HLupdates
		}

		select {
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
	// STOPSENDONLY OMIT
}

// mergedLoop is a version of loop that combines loopCloseOnly,
// loopFetchOnly, and loopSendOnly.
func (s *sub) mergedLoop() {
	// STARTFETCHVARS OMIT
	var pending []Item
	var next time.Time
	var err error
	// STOPFETCHVARS OMIT
	for {
		// STARTNOCAP OMIT
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		startFetch := time.After(fetchDelay)
		// STOPNOCAP OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}

		// STARTSELECT OMIT
		select {
		case errc := &lt;-s.closing: // HLcases
			errc &lt;- err
			close(s.updates)
			return
			// STARTFETCHCASE OMIT
		case &lt;-startFetch: // HLcases
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch() // HLfetch
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			pending = append(pending, fetched...) // HLfetch
			// STOPFETCHCASE OMIT
		case updates &lt;- first: // HLcases
			pending = pending[1:]
		}
		// STOPSELECT OMIT
	}
}

// dedupeLoop extends mergedLoop with deduping of fetched items.
func (s *sub) dedupeLoop() {
	const maxPending = 10
	// STARTSEEN OMIT
	var pending []Item
	var next time.Time
	var err error
	var seen = make(map[string]bool) // set of item.GUIDs // HLseen
	// STOPSEEN OMIT
	for {
		// STARTCAP OMIT
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		var startFetch &lt;-chan time.Time // HLcap
		if len(pending) &lt; maxPending {  // HLcap
			startFetch = time.After(fetchDelay) // enable fetch case  // HLcap
		} // HLcap
		// STOPCAP OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}
		select {
		case errc := &lt;-s.closing:
			errc &lt;- err
			close(s.updates)
			return
		// STARTDEDUPE OMIT
		case &lt;-startFetch:
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch() // HLfetch
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			for _, item := range fetched {
				if !seen[item.GUID] { // HLdupe
					pending = append(pending, item) // HLdupe
					seen[item.GUID] = true          // HLdupe
				} // HLdupe
			}
			// STOPDEDUPE OMIT
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
}

// loop periodically fecthes Items, sends them on s.updates, and exits
// when Close is called.  It extends dedupeLoop with logic to run
// Fetch asynchronously.
func (s *sub) loop() {
	const maxPending = 10
	type fetchResult struct {
		fetched []Item
		next    time.Time
		err     error
	}
	// STARTFETCHDONE OMIT
	var fetchDone chan fetchResult // if non-nil, Fetch is running // HL
	// STOPFETCHDONE OMIT
	var pending []Item
	var next time.Time
	var err error
	var seen = make(map[string]bool)
	for {
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		// STARTFETCHIF OMIT
		var startFetch &lt;-chan time.Time
		if fetchDone == nil &amp;&amp; len(pending) &lt; maxPending { // HLfetch
			startFetch = time.After(fetchDelay) // enable fetch case
		}
		// STOPFETCHIF OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}
		// STARTFETCHASYNC OMIT
		select {
		case &lt;-startFetch: // HLfetch
			fetchDone = make(chan fetchResult, 1) // HLfetch
			go func() {
				fetched, next, err := s.fetcher.Fetch()
				fetchDone &lt;- fetchResult{fetched, next, err}
			}()
		case result := &lt;-fetchDone: // HLfetch
			fetchDone = nil // HLfetch
			// Use result.fetched, result.next, result.err
			// STOPFETCHASYNC OMIT
			fetched := result.fetched
			next, err = result.next, result.err
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			for _, item := range fetched {
				if id := item.GUID; !seen[id] { // HLdupe
					pending = append(pending, item)
					seen[id] = true // HLdupe
				}
			}
		case errc := &lt;-s.closing:
			errc &lt;- err
			close(s.updates)
			return
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
}

// naiveMerge is a version of Merge that doesn&#39;t quite work right.  In
// particular, the goroutines it starts may block forever on m.updates
// if the receiver stops receiving.
type naiveMerge struct {
	subs    []Subscription
	updates chan Item
}

// STARTNAIVEMERGE OMIT
func NaiveMerge(subs ...Subscription) Subscription {
	m := &amp;naiveMerge{
		subs:    subs,
		updates: make(chan Item),
	}
	// STARTNAIVEMERGELOOP OMIT
	for _, sub := range subs {
		go func(s Subscription) {
			for it := range s.Updates() {
				m.updates &lt;- it // HL
			}
		}(sub)
	}
	// STOPNAIVEMERGELOOP OMIT
	return m
}

// STOPNAIVEMERGE OMIT

// STARTNAIVEMERGECLOSE OMIT
func (m *naiveMerge) Close() (err error) {
	for _, sub := range m.subs {
		if e := sub.Close(); err == nil &amp;&amp; e != nil {
			err = e
		}
	}
	close(m.updates) // HL
	return
}

// STOPNAIVEMERGECLOSE OMIT

func (m *naiveMerge) Updates() &lt;-chan Item {
	return m.updates
}

type merge struct {
	subs    []Subscription
	updates chan Item
	quit    chan struct{}
	errs    chan error
}

// STARTMERGESIG OMIT
// Merge returns a Subscription that merges the item streams from subs.
// Closing the merged subscription closes subs.
func Merge(subs ...Subscription) Subscription {
	// STOPMERGESIG OMIT
	m := &amp;merge{
		subs:    subs,
		updates: make(chan Item),
		quit:    make(chan struct{}),
		errs:    make(chan error),
	}
	// STARTMERGE OMIT
	for _, sub := range subs {
		go func(s Subscription) {
			for {
				var it Item
				select {
				case it = &lt;-s.Updates():
				case &lt;-m.quit: // HL
					m.errs &lt;- s.Close() // HL
					return              // HL
				}
				select {
				case m.updates &lt;- it:
				case &lt;-m.quit: // HL
					m.errs &lt;- s.Close() // HL
					return              // HL
				}
			}
		}(sub)
	}
	// STOPMERGE OMIT
	return m
}

func (m *merge) Updates() &lt;-chan Item {
	return m.updates
}

// STARTMERGECLOSE OMIT
func (m *merge) Close() (err error) {
	close(m.quit) // HL
	for _ = range m.subs {
		if e := &lt;-m.errs; e != nil { // HL
			err = e
		}
	}
	close(m.updates) // HL
	return
}

// STOPMERGECLOSE OMIT

// NaiveDedupe converts a stream of Items that may contain duplicates
// into one that doesn&#39;t.
func NaiveDedupe(in &lt;-chan Item) &lt;-chan Item {
	out := make(chan Item)
	go func() {
		seen := make(map[string]bool)
		for it := range in {
			if !seen[it.GUID] {
				// BUG: this send blocks if the
				// receiver closes the Subscription
				// and stops receiving.
				out &lt;- it // HL
				seen[it.GUID] = true
			}
		}
		close(out)
	}()
	return out
}

type deduper struct {
	s       Subscription
	updates chan Item
	closing chan chan error
}

// Dedupe converts a Subscription that may send duplicate Items into
// one that doesn&#39;t.
func Dedupe(s Subscription) Subscription {
	d := &amp;deduper{
		s:       s,
		updates: make(chan Item),
		closing: make(chan chan error),
	}
	go d.loop()
	return d
}

func (d *deduper) loop() {
	in := d.s.Updates() // enable receive
	var pending Item
	var out chan Item // disable send
	seen := make(map[string]bool)
	for {
		select {
		case it := &lt;-in:
			if !seen[it.GUID] {
				pending = it
				in = nil        // disable receive
				out = d.updates // enable send
				seen[it.GUID] = true
			}
		case out &lt;- pending:
			in = d.s.Updates() // enable receive
			out = nil          // disable send
		case errc := &lt;-d.closing:
			err := d.s.Close()
			errc &lt;- err
			close(d.updates)
			return
		}
	}
}

func (d *deduper) Close() error {
	errc := make(chan error)
	d.closing &lt;- errc
	return &lt;-errc
}

func (d *deduper) Updates() &lt;-chan Item {
	return d.updates
}

// Fetch returns a Fetcher for Items from domain.
func Fetch(domain string) Fetcher {
	return fakeFetch(domain)
}

func fakeFetch(domain string) Fetcher {
	return &amp;fakeFetcher{channel: domain}
}

type fakeFetcher struct {
	channel string
	items   []Item
}

// FakeDuplicates causes the fake fetcher to return duplicate items.
var FakeDuplicates bool

func (f *fakeFetcher) Fetch() (items []Item, next time.Time, err error) {
	now := time.Now()
	next = now.Add(time.Duration(rand.Intn(5)) * 500 * time.Millisecond)
	item := Item{
		Channel: f.channel,
		Title:   fmt.Sprintf(&#34;Item %d&#34;, len(f.items)),
	}
	item.GUID = item.Channel &#43; &#34;/&#34; &#43; item.Title
	f.items = append(f.items, item)
	if FakeDuplicates {
		items = f.items
	} else {
		items = []Item{item}
	}
	return
}

func init() {
	rand.Seed(time.Now().UnixNano())
}

// STARTMAIN OMIT
</span></pre>

<pre><span num="526">func main() {</span>
<span num="528">    // Subscribe to some feeds, and create a merged update stream.</span>
<span num="529">    merged := Merge(</span>
<span num="530">        Subscribe(Fetch(&#34;blog.golang.org&#34;)),</span>
<span num="531">        Subscribe(Fetch(&#34;googleblog.blogspot.com&#34;)),</span>
<span num="532">        Subscribe(Fetch(&#34;googledevelopers.blogspot.com&#34;)))</span>
<span num="534"></span>
<span num="535">    // Close the subscriptions after some time.</span>
<span num="536">    time.AfterFunc(3*time.Second, func() {</span>
<span num="537">        fmt.Println(&#34;closed:&#34;, merged.Close())</span>
<span num="538">    })</span>
<span num="539"></span>
<span num="540">    // Print the stream.</span>
<span num="541">    for it := range merged.Updates() {</span>
<span num="542">        fmt.Println(it.Channel, it.Title)</span>
<span num="543">    }</span>
<span num="544"></span>
<span num="545">    panic(&#34;show me the stacks&#34;)</span>
<span num="546">}</span>
</pre>

<pre style="display: none"><span>
// STOPMAIN OMIT
</span></pre>
</div>

      
      <span class="pagenumber">14</span>
      </article>
  
  
  
      <article >
      
        <h3>Subscribe</h3>
        
  
  <p>
    <code>Subscribe</code> creates a new <code>Subscription</code> that repeatedly fetches items until <code>Close</code> is called.
  </p>
  

  
  <div class="code"><pre>func Subscribe(fetcher Fetcher) Subscription {
    s := &amp;sub{
        fetcher: fetcher,
        updates: make(chan Item), // for Updates
    }
    go s.loop()
    return s
}

// sub implements the Subscription interface.
type sub struct {
    fetcher Fetcher   // fetches items
    updates chan Item // delivers items to the user
}

// loop fetches items using s.fetcher and sends them
// on s.updates.  loop exits when s.Close is called.
func (s *sub) loop() {...}</pre></div>
  

      
      <span class="pagenumber">15</span>
      </article>
  
  
  
      <article >
      
        <h3>Implementing Subscription</h3>
        
  
  <p>
    To implement the <code>Subscription</code> interface, define <code>Updates</code> and <code>Close</code>.
  </p>
  

  <div class="code" >


<pre><span num="60">func (s *sub) Updates() &lt;-chan Item {</span>
<span num="61">    return s.updates</span>
<span num="62">}</span>
</pre>


</div>

  
  <div class="code"><pre>func (s *sub) Close() error {
    // TODO: make loop exit
    // TODO: find out about any error
    return err
}</pre></div>
  

      
      <span class="pagenumber">16</span>
      </article>
  
  
  
      <article >
      
        <h3>What does loop do?</h3>
        
  <ul>
  
    <li>periodically call <code>Fetch</code></li>
  
    <li>send fetched items on the <code>Updates</code> channel</li>
  
    <li>exit when <code>Close</code> is called, reporting any error</li>
  
  </ul>

      
      <span class="pagenumber">17</span>
      </article>
  
  
  
      <article >
      
        <h3>Naive Implementation</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>// naivemain runs the Subscribe example with the naive Subscribe
// implementation and a fake RSS fetcher.
// &#43;build OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

// STARTITEM OMIT
// An Item is a stripped-down RSS item.
type Item struct{ Title, Channel, GUID string }

// STOPITEM OMIT

// STARTFETCHER OMIT
// A Fetcher fetches Items and returns the time when the next fetch should be
// attempted.  On failure, Fetch returns a non-nil error.
type Fetcher interface {
	Fetch() (items []Item, next time.Time, err error)
}

// STOPFETCHER OMIT

// STARTSUBSCRIPTION OMIT
// A Subscription delivers Items over a channel.  Close cancels the
// subscription, closes the Updates channel, and returns the last fetch error,
// if any.
type Subscription interface {
	Updates() &lt;-chan Item
	Close() error
}

// STOPSUBSCRIPTION OMIT

// STARTSUBSCRIBE OMIT
// Subscribe returns a new Subscription that uses fetcher to fetch Items.
func Subscribe(fetcher Fetcher) Subscription {
	s := &amp;sub{
		fetcher: fetcher,
		updates: make(chan Item),       // for Updates
		closing: make(chan chan error), // for Close
	}
	go s.loop()
	return s
}

// STOPSUBSCRIBE OMIT

// sub implements the Subscription interface.
type sub struct {
	fetcher Fetcher         // fetches items
	updates chan Item       // sends items to the user
	closing chan chan error // for Close
}

// STARTUPDATES OMIT
func (s *sub) Updates() &lt;-chan Item {
	return s.updates
}

// STOPUPDATES OMIT

// STARTCLOSE OMIT
// STARTCLOSESIG OMIT
func (s *sub) Close() error {
	// STOPCLOSESIG OMIT
	errc := make(chan error)
	s.closing &lt;- errc // HLchan
	return &lt;-errc     // HLchan
}

// STOPCLOSE OMIT

// loopCloseOnly is a version of loop that includes only the logic
// that handles Close.
func (s *sub) loopCloseOnly() {
	// STARTCLOSEONLY OMIT
	var err error // set when Fetch fails
	for {
		select {
		case errc := &lt;-s.closing: // HLchan
			errc &lt;- err      // HLchan
			close(s.updates) // tells receiver we&#39;re done
			return
		}
	}
	// STOPCLOSEONLY OMIT
}

// loopFetchOnly is a version of loop that includes only the logic
// that calls Fetch.
func (s *sub) loopFetchOnly() {
	// STARTFETCHONLY OMIT
	var pending []Item // appended by fetch; consumed by send
	var next time.Time // initially January 1, year 0
	var err error
	for {
		var fetchDelay time.Duration // initally 0 (no delay)
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		startFetch := time.After(fetchDelay)

		select {
		case &lt;-startFetch:
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch()
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			pending = append(pending, fetched...)
		}
	}
	// STOPFETCHONLY OMIT
}

// loopSendOnly is a version of loop that includes only the logic for
// sending items to s.updates.
func (s *sub) loopSendOnly() {
	// STARTSENDONLY OMIT
	var pending []Item // appended by fetch; consumed by send
	for {
		var first Item
		var updates chan Item // HLupdates
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case // HLupdates
		}

		select {
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
	// STOPSENDONLY OMIT
}

// mergedLoop is a version of loop that combines loopCloseOnly,
// loopFetchOnly, and loopSendOnly.
func (s *sub) mergedLoop() {
	// STARTFETCHVARS OMIT
	var pending []Item
	var next time.Time
	var err error
	// STOPFETCHVARS OMIT
	for {
		// STARTNOCAP OMIT
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		startFetch := time.After(fetchDelay)
		// STOPNOCAP OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}

		// STARTSELECT OMIT
		select {
		case errc := &lt;-s.closing: // HLcases
			errc &lt;- err
			close(s.updates)
			return
			// STARTFETCHCASE OMIT
		case &lt;-startFetch: // HLcases
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch() // HLfetch
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			pending = append(pending, fetched...) // HLfetch
			// STOPFETCHCASE OMIT
		case updates &lt;- first: // HLcases
			pending = pending[1:]
		}
		// STOPSELECT OMIT
	}
}

// dedupeLoop extends mergedLoop with deduping of fetched items.
func (s *sub) dedupeLoop() {
	const maxPending = 10
	// STARTSEEN OMIT
	var pending []Item
	var next time.Time
	var err error
	var seen = make(map[string]bool) // set of item.GUIDs // HLseen
	// STOPSEEN OMIT
	for {
		// STARTCAP OMIT
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		var startFetch &lt;-chan time.Time // HLcap
		if len(pending) &lt; maxPending {  // HLcap
			startFetch = time.After(fetchDelay) // enable fetch case  // HLcap
		} // HLcap
		// STOPCAP OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}
		select {
		case errc := &lt;-s.closing:
			errc &lt;- err
			close(s.updates)
			return
		// STARTDEDUPE OMIT
		case &lt;-startFetch:
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch() // HLfetch
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			for _, item := range fetched {
				if !seen[item.GUID] { // HLdupe
					pending = append(pending, item) // HLdupe
					seen[item.GUID] = true          // HLdupe
				} // HLdupe
			}
			// STOPDEDUPE OMIT
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
}

// loop periodically fecthes Items, sends them on s.updates, and exits
// when Close is called.  It extends dedupeLoop with logic to run
// Fetch asynchronously.
func (s *sub) loop() {
	const maxPending = 10
	type fetchResult struct {
		fetched []Item
		next    time.Time
		err     error
	}
	// STARTFETCHDONE OMIT
	var fetchDone chan fetchResult // if non-nil, Fetch is running // HL
	// STOPFETCHDONE OMIT
	var pending []Item
	var next time.Time
	var err error
	var seen = make(map[string]bool)
	for {
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		// STARTFETCHIF OMIT
		var startFetch &lt;-chan time.Time
		if fetchDone == nil &amp;&amp; len(pending) &lt; maxPending { // HLfetch
			startFetch = time.After(fetchDelay) // enable fetch case
		}
		// STOPFETCHIF OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}
		// STARTFETCHASYNC OMIT
		select {
		case &lt;-startFetch: // HLfetch
			fetchDone = make(chan fetchResult, 1) // HLfetch
			go func() {
				fetched, next, err := s.fetcher.Fetch()
				fetchDone &lt;- fetchResult{fetched, next, err}
			}()
		case result := &lt;-fetchDone: // HLfetch
			fetchDone = nil // HLfetch
			// Use result.fetched, result.next, result.err
			// STOPFETCHASYNC OMIT
			fetched := result.fetched
			next, err = result.next, result.err
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			for _, item := range fetched {
				if id := item.GUID; !seen[id] { // HLdupe
					pending = append(pending, item)
					seen[id] = true // HLdupe
				}
			}
		case errc := &lt;-s.closing:
			errc &lt;- err
			close(s.updates)
			return
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
}

// naiveMerge is a version of Merge that doesn&#39;t quite work right.  In
// particular, the goroutines it starts may block forever on m.updates
// if the receiver stops receiving.
type naiveMerge struct {
	subs    []Subscription
	updates chan Item
}

// STARTNAIVEMERGE OMIT
func NaiveMerge(subs ...Subscription) Subscription {
	m := &amp;naiveMerge{
		subs:    subs,
		updates: make(chan Item),
	}
	// STARTNAIVEMERGELOOP OMIT
	for _, sub := range subs {
		go func(s Subscription) {
			for it := range s.Updates() {
				m.updates &lt;- it // HL
			}
		}(sub)
	}
	// STOPNAIVEMERGELOOP OMIT
	return m
}

// STOPNAIVEMERGE OMIT

// STARTNAIVEMERGECLOSE OMIT
func (m *naiveMerge) Close() (err error) {
	for _, sub := range m.subs {
		if e := sub.Close(); err == nil &amp;&amp; e != nil {
			err = e
		}
	}
	close(m.updates) // HL
	return
}

// STOPNAIVEMERGECLOSE OMIT

func (m *naiveMerge) Updates() &lt;-chan Item {
	return m.updates
}

type merge struct {
	subs    []Subscription
	updates chan Item
	quit    chan struct{}
	errs    chan error
}

// STARTMERGESIG OMIT
// Merge returns a Subscription that merges the item streams from subs.
// Closing the merged subscription closes subs.
func Merge(subs ...Subscription) Subscription {
	// STOPMERGESIG OMIT
	m := &amp;merge{
		subs:    subs,
		updates: make(chan Item),
		quit:    make(chan struct{}),
		errs:    make(chan error),
	}
	// STARTMERGE OMIT
	for _, sub := range subs {
		go func(s Subscription) {
			for {
				var it Item
				select {
				case it = &lt;-s.Updates():
				case &lt;-m.quit: // HL
					m.errs &lt;- s.Close() // HL
					return              // HL
				}
				select {
				case m.updates &lt;- it:
				case &lt;-m.quit: // HL
					m.errs &lt;- s.Close() // HL
					return              // HL
				}
			}
		}(sub)
	}
	// STOPMERGE OMIT
	return m
}

func (m *merge) Updates() &lt;-chan Item {
	return m.updates
}

// STARTMERGECLOSE OMIT
func (m *merge) Close() (err error) {
	close(m.quit) // HL
	for _ = range m.subs {
		if e := &lt;-m.errs; e != nil { // HL
			err = e
		}
	}
	close(m.updates) // HL
	return
}

// STOPMERGECLOSE OMIT

// NaiveDedupe converts a stream of Items that may contain duplicates
// into one that doesn&#39;t.
func NaiveDedupe(in &lt;-chan Item) &lt;-chan Item {
	out := make(chan Item)
	go func() {
		seen := make(map[string]bool)
		for it := range in {
			if !seen[it.GUID] {
				// BUG: this send blocks if the
				// receiver closes the Subscription
				// and stops receiving.
				out &lt;- it // HL
				seen[it.GUID] = true
			}
		}
		close(out)
	}()
	return out
}

type deduper struct {
	s       Subscription
	updates chan Item
	closing chan chan error
}

// Dedupe converts a Subscription that may send duplicate Items into
// one that doesn&#39;t.
func Dedupe(s Subscription) Subscription {
	d := &amp;deduper{
		s:       s,
		updates: make(chan Item),
		closing: make(chan chan error),
	}
	go d.loop()
	return d
}

func (d *deduper) loop() {
	in := d.s.Updates() // enable receive
	var pending Item
	var out chan Item // disable send
	seen := make(map[string]bool)
	for {
		select {
		case it := &lt;-in:
			if !seen[it.GUID] {
				pending = it
				in = nil        // disable receive
				out = d.updates // enable send
				seen[it.GUID] = true
			}
		case out &lt;- pending:
			in = d.s.Updates() // enable receive
			out = nil          // disable send
		case errc := &lt;-d.closing:
			err := d.s.Close()
			errc &lt;- err
			close(d.updates)
			return
		}
	}
}

func (d *deduper) Close() error {
	errc := make(chan error)
	d.closing &lt;- errc
	return &lt;-errc
}

func (d *deduper) Updates() &lt;-chan Item {
	return d.updates
}

// Fetch returns a Fetcher for Items from domain.
func Fetch(domain string) Fetcher {
	return fakeFetch(domain)
}

func fakeFetch(domain string) Fetcher {
	return &amp;fakeFetcher{channel: domain}
}

type fakeFetcher struct {
	channel string
	items   []Item
}

// FakeDuplicates causes the fake fetcher to return duplicate items.
var FakeDuplicates bool

func (f *fakeFetcher) Fetch() (items []Item, next time.Time, err error) {
	now := time.Now()
	next = now.Add(time.Duration(rand.Intn(5)) * 500 * time.Millisecond)
	item := Item{
		Channel: f.channel,
		Title:   fmt.Sprintf(&#34;Item %d&#34;, len(f.items)),
	}
	item.GUID = item.Channel &#43; &#34;/&#34; &#43; item.Title
	f.items = append(f.items, item)
	if FakeDuplicates {
		items = f.items
	} else {
		items = []Item{item}
	}
	return
}

func NaiveSubscribe(fetcher Fetcher) Subscription {
	s := &amp;naiveSub{
		fetcher: fetcher,
		updates: make(chan Item),
	}
	go s.loop()
	return s
}

type naiveSub struct {
	fetcher Fetcher
	updates chan Item
	closed  bool
	err     error
}

func (s *naiveSub) Updates() &lt;-chan Item {
	return s.updates
}

func (s *naiveSub) loop() {
</span></pre>

<pre><span num="544">    for {</span>
<span num="545">        if s.closed {</span>
<span num="546">            close(s.updates)</span>
<span num="547">            return</span>
<span num="548">        }</span>
<span num="549">        items, next, err := s.fetcher.Fetch()</span>
<span num="550">        if err != nil {</span>
<span num="551">            s.err = err                 </span>
<span num="552">            time.Sleep(10 * time.Second)</span>
<span num="553">            continue</span>
<span num="554">        }</span>
<span num="555">        for _, item := range items {</span>
<span num="556">            s.updates &lt;- item</span>
<span num="557">        }</span>
<span num="558">        if now := time.Now(); next.After(now) {</span>
<span num="559">            time.Sleep(next.Sub(now))</span>
<span num="560">        }</span>
<span num="561">    }</span>
</pre>

<pre style="display: none"><span>}

func (s *naiveSub) Close() error {
	s.closed = true // HLsync
	return s.err    // HLsync
}

func init() {
	rand.Seed(time.Now().UnixNano())
}

func main() {
	// Subscribe to some feeds, and create a merged update stream.
	merged := Merge(
		NaiveSubscribe(Fetch(&#34;blog.golang.org&#34;)),
		NaiveSubscribe(Fetch(&#34;googleblog.blogspot.com&#34;)),
		NaiveSubscribe(Fetch(&#34;googledevelopers.blogspot.com&#34;)))

	// Close the subscriptions after some time.
	time.AfterFunc(3*time.Second, func() {
		fmt.Println(&#34;closed:&#34;, merged.Close())
	})

	// Print the stream.
	for it := range merged.Updates() {
		fmt.Println(it.Channel, it.Title)
	}

	// The loops are still running.  Let the race detector notice.
	time.Sleep(1 * time.Second)

	panic(&#34;show me the stacks&#34;)
}
</span></pre>
</div>

  <div class="code" >


<pre><span num="565">func (s *naiveSub) Close() error {</span>
<span num="566">    s.closed = true</span>
<span num="567">    return s.err   </span>
<span num="568">}</span>
</pre>


</div>

      
      <span class="pagenumber">18</span>
      </article>
  
  
  
      <article >
      
        <h3>Bug 1: unsynchronized access to s.closed/s.err</h3>
        
  <div class="code" >


<pre><span num="544">    for {</span>
<span num="545">        <b>if s.closed {</b></span>
<span num="546">            close(s.updates)</span>
<span num="547">            return</span>
<span num="548">        }</span>
<span num="549">        items, next, err := s.fetcher.Fetch()</span>
<span num="550">        if err != nil {</span>
<span num="551">            <b>s.err = err</b></span>
<span num="552">            time.Sleep(10 * time.Second)</span>
<span num="553">            continue</span>
<span num="554">        }</span>
<span num="555">        for _, item := range items {</span>
<span num="556">            s.updates &lt;- item</span>
<span num="557">        }</span>
<span num="558">        if now := time.Now(); next.After(now) {</span>
<span num="559">            time.Sleep(next.Sub(now))</span>
<span num="560">        }</span>
<span num="561">    }</span>
</pre>


</div>

  <div class="code" >


<pre><span num="565">func (s *naiveSub) Close() error {</span>
<span num="566">    <b>s.closed = true</b></span>
<span num="567">    <b>return s.err</b></span>
<span num="568">}</span>
</pre>


</div>

      
      <span class="pagenumber">19</span>
      </article>
  
  
  
      <article >
      
        <h3>Race Detector</h3>
        
  
  <div class="code"><pre>go run -race naivemain.go</pre></div>
  

<div class="image">
  <img src="advconc/race.png" height="150" width="562">
</div>

  <div class="code playground" >
<pre style="display: none"><span>// naivemain runs the Subscribe example with the naive Subscribe
// implementation and a fake RSS fetcher.
// &#43;build OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

// STARTITEM OMIT
// An Item is a stripped-down RSS item.
type Item struct{ Title, Channel, GUID string }

// STOPITEM OMIT

// STARTFETCHER OMIT
// A Fetcher fetches Items and returns the time when the next fetch should be
// attempted.  On failure, Fetch returns a non-nil error.
type Fetcher interface {
	Fetch() (items []Item, next time.Time, err error)
}

// STOPFETCHER OMIT

// STARTSUBSCRIPTION OMIT
// A Subscription delivers Items over a channel.  Close cancels the
// subscription, closes the Updates channel, and returns the last fetch error,
// if any.
type Subscription interface {
	Updates() &lt;-chan Item
	Close() error
}

// STOPSUBSCRIPTION OMIT

// STARTSUBSCRIBE OMIT
// Subscribe returns a new Subscription that uses fetcher to fetch Items.
func Subscribe(fetcher Fetcher) Subscription {
	s := &amp;sub{
		fetcher: fetcher,
		updates: make(chan Item),       // for Updates
		closing: make(chan chan error), // for Close
	}
	go s.loop()
	return s
}

// STOPSUBSCRIBE OMIT

// sub implements the Subscription interface.
type sub struct {
	fetcher Fetcher         // fetches items
	updates chan Item       // sends items to the user
	closing chan chan error // for Close
}

// STARTUPDATES OMIT
func (s *sub) Updates() &lt;-chan Item {
	return s.updates
}

// STOPUPDATES OMIT

// STARTCLOSE OMIT
// STARTCLOSESIG OMIT
func (s *sub) Close() error {
	// STOPCLOSESIG OMIT
	errc := make(chan error)
	s.closing &lt;- errc // HLchan
	return &lt;-errc     // HLchan
}

// STOPCLOSE OMIT

// loopCloseOnly is a version of loop that includes only the logic
// that handles Close.
func (s *sub) loopCloseOnly() {
	// STARTCLOSEONLY OMIT
	var err error // set when Fetch fails
	for {
		select {
		case errc := &lt;-s.closing: // HLchan
			errc &lt;- err      // HLchan
			close(s.updates) // tells receiver we&#39;re done
			return
		}
	}
	// STOPCLOSEONLY OMIT
}

// loopFetchOnly is a version of loop that includes only the logic
// that calls Fetch.
func (s *sub) loopFetchOnly() {
	// STARTFETCHONLY OMIT
	var pending []Item // appended by fetch; consumed by send
	var next time.Time // initially January 1, year 0
	var err error
	for {
		var fetchDelay time.Duration // initally 0 (no delay)
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		startFetch := time.After(fetchDelay)

		select {
		case &lt;-startFetch:
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch()
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			pending = append(pending, fetched...)
		}
	}
	// STOPFETCHONLY OMIT
}

// loopSendOnly is a version of loop that includes only the logic for
// sending items to s.updates.
func (s *sub) loopSendOnly() {
	// STARTSENDONLY OMIT
	var pending []Item // appended by fetch; consumed by send
	for {
		var first Item
		var updates chan Item // HLupdates
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case // HLupdates
		}

		select {
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
	// STOPSENDONLY OMIT
}

// mergedLoop is a version of loop that combines loopCloseOnly,
// loopFetchOnly, and loopSendOnly.
func (s *sub) mergedLoop() {
	// STARTFETCHVARS OMIT
	var pending []Item
	var next time.Time
	var err error
	// STOPFETCHVARS OMIT
	for {
		// STARTNOCAP OMIT
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		startFetch := time.After(fetchDelay)
		// STOPNOCAP OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}

		// STARTSELECT OMIT
		select {
		case errc := &lt;-s.closing: // HLcases
			errc &lt;- err
			close(s.updates)
			return
			// STARTFETCHCASE OMIT
		case &lt;-startFetch: // HLcases
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch() // HLfetch
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			pending = append(pending, fetched...) // HLfetch
			// STOPFETCHCASE OMIT
		case updates &lt;- first: // HLcases
			pending = pending[1:]
		}
		// STOPSELECT OMIT
	}
}

// dedupeLoop extends mergedLoop with deduping of fetched items.
func (s *sub) dedupeLoop() {
	const maxPending = 10
	// STARTSEEN OMIT
	var pending []Item
	var next time.Time
	var err error
	var seen = make(map[string]bool) // set of item.GUIDs // HLseen
	// STOPSEEN OMIT
	for {
		// STARTCAP OMIT
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		var startFetch &lt;-chan time.Time // HLcap
		if len(pending) &lt; maxPending {  // HLcap
			startFetch = time.After(fetchDelay) // enable fetch case  // HLcap
		} // HLcap
		// STOPCAP OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}
		select {
		case errc := &lt;-s.closing:
			errc &lt;- err
			close(s.updates)
			return
		// STARTDEDUPE OMIT
		case &lt;-startFetch:
			var fetched []Item
			fetched, next, err = s.fetcher.Fetch() // HLfetch
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			for _, item := range fetched {
				if !seen[item.GUID] { // HLdupe
					pending = append(pending, item) // HLdupe
					seen[item.GUID] = true          // HLdupe
				} // HLdupe
			}
			// STOPDEDUPE OMIT
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
}

// loop periodically fecthes Items, sends them on s.updates, and exits
// when Close is called.  It extends dedupeLoop with logic to run
// Fetch asynchronously.
func (s *sub) loop() {
	const maxPending = 10
	type fetchResult struct {
		fetched []Item
		next    time.Time
		err     error
	}
	// STARTFETCHDONE OMIT
	var fetchDone chan fetchResult // if non-nil, Fetch is running // HL
	// STOPFETCHDONE OMIT
	var pending []Item
	var next time.Time
	var err error
	var seen = make(map[string]bool)
	for {
		var fetchDelay time.Duration
		if now := time.Now(); next.After(now) {
			fetchDelay = next.Sub(now)
		}
		// STARTFETCHIF OMIT
		var startFetch &lt;-chan time.Time
		if fetchDone == nil &amp;&amp; len(pending) &lt; maxPending { // HLfetch
			startFetch = time.After(fetchDelay) // enable fetch case
		}
		// STOPFETCHIF OMIT
		var first Item
		var updates chan Item
		if len(pending) &gt; 0 {
			first = pending[0]
			updates = s.updates // enable send case
		}
		// STARTFETCHASYNC OMIT
		select {
		case &lt;-startFetch: // HLfetch
			fetchDone = make(chan fetchResult, 1) // HLfetch
			go func() {
				fetched, next, err := s.fetcher.Fetch()
				fetchDone &lt;- fetchResult{fetched, next, err}
			}()
		case result := &lt;-fetchDone: // HLfetch
			fetchDone = nil // HLfetch
			// Use result.fetched, result.next, result.err
			// STOPFETCHASYNC OMIT
			fetched := result.fetched
			next, err = result.next, result.err
			if err != nil {
				next = time.Now().Add(10 * time.Second)
				break
			}
			for _, item := range fetched {
				if id := item.GUID; !seen[id] { // HLdupe
					pending = append(pending, item)
					seen[id] = true // HLdupe
				}
			}
		case errc := &lt;-s.closing:
			errc &lt;- err
			close(s.updates)
			return
		case updates &lt;- first:
			pending = pending[1:]
		}
	}
}

// naiveMerge is a version of Merge that doesn&#39;t quite work right.  In
// particular, the goroutines it starts may block forever on m.updates
// if the receiver stops receiving.
type naiveMerge struct {
	subs    []Subscription
	updates chan Item
}

// STARTNAIVEMERGE OMIT
func NaiveMerge(subs ...Subscription) Subscription {
	m := &amp;naiveMerge{
		subs:    subs,
		updates: make(chan Item),
	}
	// STARTNAIVEMERGELOOP OMIT
	for _, sub := range subs {
		go func(s Subscription) {
			for it := range s.Updates() {
				m.updates &lt;- it // HL
			}
		}(sub)
	}
	// STOPNAIVEMERGELOOP OMIT
	return m
}

// STOPNAIVEMERGE OMIT

// STARTNAIVEMERGECLOSE OMIT
func (m *naiveMerge) Close() (err error) {
	for _, sub := range m.subs {
		if e := sub.Close(); err == nil &amp;&amp; e != nil {
			err = e
		}
	}
	close(m.updates) // HL
	return
}

// STOPNAIVEMERGECLOSE OMIT

func (m *naiveMerge) Updates() &lt;-chan Item {
	return m.updates
}

type merge struct {
	subs    []Subscription
	updates chan Item
	quit    chan struct{}
	errs    chan error
}

// STARTMERGESIG OMIT
// Merge returns a Subscription that merges the item streams from subs.
// Closing the merged subscription closes subs.
func Merge(subs ...Subscription) Subscription {
	// STOPMERGESIG OMIT
	m := &amp;merge{
		subs:    subs,
		updates: make(chan Item),
		quit:    make(chan struct{}),
		errs:    make(chan error),
	}
	// STARTMERGE OMIT
	for _, sub := range subs {
		go func(s Subscription) {
			for {
				var it Item
				select {
				case it = &lt;-s.Updates():
				case &lt;-m.quit: // HL
					m.errs &lt;- s.Close() // HL
					return              // HL
				}
				select {
				case m.updates &lt;- it:
				case &lt;-m.quit: // HL
					m.errs &lt;- s.Close() // HL
					return              // HL
				}
			}
		}(sub)
	}
	// STOPMERGE OMIT
	return m
}

func (m *merge) Updates() &lt;-chan Item {
	return m.updates
}

// STARTMERGECLOSE OMIT
func (m *merge) Close() (err error) {
	close(m.quit) // HL
	for _ = range m.subs {
		if e := &lt;-m.errs; e != nil { // HL
			err = e
		}
	}
	close(m.updates) // HL
	return
}

// STOPMERGECLOSE OMIT

// NaiveDedupe converts a stream of Items that may contain duplicates
// into one that doesn&#39;t.
func NaiveDedupe(in &lt;-chan Item) &lt;-chan Item {
	out := make(chan Item)
	go func() {
		seen := make(map[string]bool)
		for it := range in {
			if !seen[it.GUID] {
				// BUG: this send blocks if the
				// receiver closes the Subscription
				// and stops receiving.
				out &lt;- it // HL
				seen[it.GUID] = true
			}
		}
		close(out)
	}()
	return out
}

type deduper struct {
	s       Subscription
	updates chan Item
	closing chan chan error
}

// Dedupe converts a Subscription that may send duplicate Items into
// one that doesn&#39;t.
func Dedupe(s Subscription) Subscription {
	d := &amp;deduper{
		s:       s,
		updates: make(chan Item),
		closing: make(chan chan error),
	}
	go d.loop()
	return d
}

func (d *deduper) loop() {
	in := d.s.Updates() // enable receive
	var pending Item
	var out chan Item // disable send
	seen := make(map[string]bool)
	for {
		select {
		case it := &lt;-in:
			if !seen[it.GUID] {
				pending = it
				in = nil        // disable receive
				out = d.updates // enable send
				seen[it.GUID] = true
			}
		case out &lt;- pending:
			in = d.s.Updates() // enable receive
			out = nil          // disable send
		case errc := &lt;-d.closing:
			err := d.s.Close()
			errc &lt;- err
			close(d.updates)
			return
		}
	}
}

func (d *deduper) Close() error {
	errc := make(chan error)
	d.closing &lt;- errc
	return &lt;-errc
}

func (d *deduper) Updates() &lt;-chan Item {
	return d.updates
}

// Fetch returns a Fetcher for Items from domain.
func Fetch(domain string) Fetcher {
	return fakeFetch(domain)
}

func fakeFetch(domain string) Fetcher {
	return &amp;fakeFetcher{channel: domain}
}

type fakeFetcher struct {
	channel string
	items   []Item
}

// FakeDuplicates causes the fake fetcher to return duplicate items.
var FakeDuplicates bool

func (f *fakeFetcher) Fetch() (items []Item, next time.Time, err error) {
	now := time.Now()
	next = now.Add(time.Duration(rand.Intn(5)) * 500 * time.Millisecond)
	item := Item{
		Channel: f.channel,
		Title:   fmt.Sprintf(&#34;Item %d&#34;, len(f.items)),
	}
	item.GUID = item.Channel &#43; &#34;/&#34; &#43; item.Title
	f.items = append(f.items, item)
	if FakeDuplicates {
		items = f.items
	} else {
		items = []Item{item}
	}
	return
}

func NaiveSubscribe(fetcher Fetcher) Subscription {
	s := &amp;naiveSub{
		fetcher: fetcher,
		updates: make(chan Item),
	}
	go s.loop()
	return s
}

type naiveSub struct {
	fetcher Fetcher
	updates chan Item
	closed  bool
	err     error
}

func (s *naiveSub) Updates() &lt;-chan Item {
	return s.updates
}

func (s *naiveSub) loop() {
</span></pre>

<pre><span num="544">    for {</span>
<span num="545">        <b>if s.closed {</b></span>
<span num="546">            close(s.updates)</span>
<span num="547">            return</span>
<span num="548">        }</span>
<span num="549">        items, next, err := s.fetcher.Fetch()</span>
<span num="550">        if err != nil {</span>
<span num="551">            <b>s.err = err</b></span>
</pre>

<pre style="display: none"><span>			time.Sleep(10 * time.Second) // HLsleep
			continue
		}
		for _, item := range items {
			s.updates &lt;- item // HLsend
		}
		if now := time.Now(); next.After(now) {
			time.Sleep(next.Sub(now)) // HLsleep
		}
	}
	// STOPNAIVE OMIT
}

func (s *naiveSub) Close() error {
	s.closed = true // HLsync
	return s.err    // HLsync
}

func init() {
	rand.Seed(time.Now().UnixNano())
}

func main() {
	// Subscribe to some feeds, and create a merged update stream.
	merged := Merge(
		NaiveSubscribe(Fetch(&#34;blog.golang.org&#34;)),
		NaiveSubscribe(Fetch(&#34;googleblog.blogspot.com&#34;)),
		NaiveSubscribe(Fetch(&#34;googledevelopers.blogspot.com&#34;)))

	// Close the subscriptions after some time.
	time.AfterFunc(3*time.Second, func() {
		fmt.Println(&#34;closed:&#34;, merged.Close())
	})

	// Print the stream.
	for it := range merged.Updates() {
		fmt.Println(it.Channel, it.Title)
	}

	// The loops are still running.  Let the race detector notice.
	time.Sleep(1 * time.Second)

	panic(&#34;show me the stacks&#34;)
}
</span></pre>
</div>

  <div class="code" >


<pre><span num="565">func (s *naiveSub) Close() error {</span>
<span num="566">    <b>s.closed = true</b></span>
<span num="567">    <b>return s.err</b></span>
<span num="568">}</span>
</pre>


</div>

      
      <span class="pagenumber">20</span>
      </article>
  
  
  
      <article >
      
        <h3>Bug 2: time.Sleep may keep loop running</h3>
        
  <div class="code" >


<pre><span num="544">    for {</span>
<span num="545">        if s.closed {</span>
<span num="546">            close(s.updates)</span>
<span num="547">            return</span>
<span num="548">        }</span>
<span num="549">        items, next, err := s.fetcher.Fetch()</span>
<span num="550">        if err != nil {</span>
<span num="551">            s.err = err                 </span>
<span num="552">            <b>time.Sleep(10 * time.Second)</b></span>
<span num="553">            continue</span>
<span num="554">        }</span>
<span num="555">        for _, item := range items {</span>
<span num="556">            s.updates &lt;- item</span>
<span num="557">        }</span>
<span num="558">        if now := time.Now(); next.After(now) {</span>
<span num="559">            <b>time.Sleep(next.Sub(now))</b></span>
<span num="560">        }</span>
<span num="561">    }</span>
</pre>


</div>

      
      <span class="pagenumber">21</span>
      </article>
  
  
  
      <article >
      
        <h3>Bug 3: loop may block forever on s.updates</h3>
        
  <div class="code" >


<pre><span num="544">    for {</span>
<span num="545">        if s.closed {</span>
<span num="546">            close(s.updates)</span>
<span num="547">            return</span>
<span num="548">        }</span>
<span num="549">        items, next, err := s.fetcher.Fetch()</span>
<span num="550">        if err != nil {</span>
<span num="551">            s.err = err                 </span>
<span num="552">            time.Sleep(10 * time.Second)</span>
<span num="553">            continue</span>
<span num="554">        }</span>
<span num="555">        for _, item := range items {</span>
<span num="556">            <b>s.updates &lt;- item</b></span>
<span num="557">        }</span>
<span num="558">        if now := time.Now(); next.After(now) {</span>
<span num="559">            time.Sleep(next.Sub(now))</span>
<span num="560">        }</span>
<span num="561">    }</span>
</pre>


</div>

      
      <span class="pagenumber">22</span>
      </article>
  
  
  
      <article >
      
        <h3>Solution</h3>
        
  
  <p>
    Change the body of <code>loop</code> to a <code>select</code> with three cases:
  </p>
  

  <ul>
  
    <li><code>Close</code> was called</li>
  
    <li>it&#39;s time to call <code>Fetch</code></li>
  
    <li>send an item on <code>s.updates</code></li>
  
  </ul>

      
      <span class="pagenumber">23</span>
      </article>
  
  
  
      <article >
      
        <h3>Structure: for-select loop</h3>
        
  
  <p>
    <code>loop</code> runs in its own goroutine.
  </p>
  

  
  <p>
    <code>select</code> lets <code>loop</code> avoid blocking indefinitely in any one state.
  </p>
  

  
  <div class="code"><pre>func (s *sub) loop() {
    ... declare mutable state ...
    for {
        ... set up channels for cases ...
        select {
        case &lt;-c1:
            ... read/write state ...
        case c2 &lt;- x:
            ... read/write state ...
        case y := &lt;-c3:
            ... read/write state ...
        }
    }
}</pre></div>
  

  
  <p>
    The cases interact via local state in <code>loop</code>.
  </p>
  

      
      <span class="pagenumber">24</span>
      </article>
  
  
  
      <article >
      
        <h3>Case 1: Close</h3>
        
  
  <p>
    <code>Close</code> communicates with <code>loop</code> via <code>s.closing</code>.
  </p>
  

  
  <div class="code"><pre>type sub struct {
    closing chan chan error
}</pre></div>
  

  
  <p>
    The service (<code>loop</code>) listens for requests on its channel (<code>s.closing</code>).
  </p>
  

  
  <p>
    The client (<code>Close</code>) sends a request on <code>s.closing</code>: <i>exit and reply with the error</i>
  </p>
  

  
  <p>
    In this case, the only thing in the request is the <i>reply channel</i>.
  </p>
  

      
      <span class="pagenumber">25</span>
      </article>
  
  
  
      <article >
      
        <h3>Case 1: Close</h3>
        
  
  <p>
    <code>Close</code> asks loop to exit and waits for a response.
  </p>
  

  <div class="code" >


<pre><span num="68">func (s *sub) Close() error {</span>
<span num="70">    errc := make(chan error)</span>
<span num="71">    <b>s.closing &lt;- errc</b></span>
<span num="72">    <b>return &lt;-errc</b></span>
<span num="73">}</span>
</pre>


</div>

  
  <p>
    <code>loop</code> handles <code>Close</code> by replying with the <code>Fetch</code> error and exiting.
  </p>
  

  <div class="code" >


<pre><span num="81">    var err error // set when Fetch fails</span>
<span num="82">    for {</span>
<span num="83">        select {</span>
<span num="84">        <b>case errc := &lt;-s.closing:</b></span>
<span num="85">            <b>errc &lt;- err</b></span>
<span num="86">            close(s.updates) // tells receiver we&#39;re done</span>
<span num="87">            return</span>
<span num="88">        }</span>
<span num="89">    }</span>
</pre>


</div>

      
      <span class="pagenumber">26</span>
      </article>
  
  
  
      <article >
      
        <h3>Case 2: Fetch</h3>
        
  
  <p>
    Schedule the next <code>Fetch</code> after some delay.
  </p>
  

  <div class="code" >


<pre><span num="97">    var pending []Item // appended by fetch; consumed by send</span>
<span num="98">    var next time.Time // initially January 1, year 0</span>
<span num="99">    var err error</span>
<span num="100">    for {</span>
<span num="101">        var fetchDelay time.Duration // initally 0 (no delay)</span>
<span num="102">        if now := time.Now(); next.After(now) {</span>
<span num="103">            fetchDelay = next.Sub(now)</span>
<span num="104">        }</span>
<span num="105">        startFetch := time.After(fetchDelay)</span>
<span num="106"></span>
<span num="107">        select {</span>
<span num="108">        case &lt;-startFetch:</span>
<span num="109">            var fetched []Item</span>
<span num="110">            fetched, next, err = s.fetcher.Fetch()</span>
<span num="111">            if err != nil {</span>
<span num="112">                next = time.Now().Add(10 * time.Second)</span>
<span num="113">                break</span>
<span num="114">            }</span>
<span num="115">            pending = append(pending, fetched...)</span>
<span num="116">        }</span>
<span num="117">    }</span>
</pre>


</div>

      
      <span class="pagenumber">27</span>
      </article>
  
  
  
      <article >
      
        <h3>Case 3: Send</h3>
        
  
  <p>
    Send the fetched items, one at a time.
  </p>
  

  
  <div class="code"><pre>var pending []Item // appended by fetch; consumed by send
for {
    select {
    case s.updates &lt;- pending[0]:
        pending = pending[1:]
    }
}</pre></div>
  

  
  <p>
    Whoops. This crashes.
  </p>
  

<div class="image">
  <img src="advconc/gopherswrench.jpg" height="200" width="337">
</div>

      
      <span class="pagenumber">28</span>
      </article>
  
  
  
      <article >
      
        <h3>Select and nil channels</h3>
        
  
  <p>
    Sends and receives on nil channels block.
  </p>
  

  
  <p>
    Select never selects a blocking case.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

</span></pre>

<pre><span num="15">func main() {</span>
<span num="16">    a, b := make(chan string), make(chan string)</span>
<span num="17">    go func() { a &lt;- &#34;a&#34; }()</span>
<span num="18">    go func() { b &lt;- &#34;b&#34; }()</span>
<span num="19">    if rand.Intn(2) == 0 {</span>
<span num="20">        <b>a = nil</b></span>
<span num="21">        fmt.Println(&#34;nil a&#34;)</span>
<span num="22">    } else {</span>
<span num="23">        <b>b = nil</b></span>
<span num="24">        fmt.Println(&#34;nil b&#34;)</span>
<span num="25">    }</span>
<span num="26">    select {</span>
<span num="27">    case s := &lt;-a:</span>
<span num="28">        fmt.Println(&#34;got&#34;, s)</span>
<span num="29">    case s := &lt;-b:</span>
<span num="30">        fmt.Println(&#34;got&#34;, s)</span>
<span num="31">    }</span>
<span num="32">}</span>
</pre>


</div>

      
      <span class="pagenumber">29</span>
      </article>
  
  
  
      <article >
      
        <h3>Case 3: Send (fixed)</h3>
        
  
  <p>
    Enable send only when pending is non-empty.
  </p>
  

  <div class="code" >


<pre><span num="125">    var pending []Item // appended by fetch; consumed by send</span>
<span num="126">    for {</span>
<span num="127">        var first Item</span>
<span num="128">        <b>var updates chan Item</b></span>
<span num="129">        if len(pending) &gt; 0 {</span>
<span num="130">            first = pending[0]</span>
<span num="131">            <b>updates = s.updates // enable send case</b></span>
<span num="132">        }</span>
<span num="133"></span>
<span num="134">        select {</span>
<span num="135">        case updates &lt;- first:</span>
<span num="136">            pending = pending[1:]</span>
<span num="137">        }</span>
<span num="138">    }</span>
</pre>


</div>

      
      <span class="pagenumber">30</span>
      </article>
  
  
  
      <article >
      
        <h3>Select</h3>
        
  
  <p>
    Put the three cases together:
  </p>
  

  <div class="code" >


<pre><span num="166">        select {</span>
<span num="167">        case errc := &lt;-s.closing:</span>
<span num="168">            errc &lt;- err</span>
<span num="169">            close(s.updates)</span>
<span num="170">            return</span>
<span num="172">        case &lt;-startFetch:</span>
<span num="173">            var fetched []Item</span>
<span num="174">            fetched, next, err = s.fetcher.Fetch()</span>
<span num="175">            if err != nil {</span>
<span num="176">                next = time.Now().Add(10 * time.Second)</span>
<span num="177">                break</span>
<span num="178">            }</span>
<span num="179">            pending = append(pending, fetched...)</span>
<span num="181">        case updates &lt;- first:</span>
<span num="182">            pending = pending[1:]</span>
<span num="183">        }</span>
</pre>


</div>

  
  <p>
    The cases interact via <code>err</code>, <code>next</code>, and <code>pending</code>.
  </p>
  

  
  <p>
    No locks, no condition variables, no callbacks.
  </p>
  

      
      <span class="pagenumber">31</span>
      </article>
  
  
  
      <article >
      
        <h3>Bugs fixed</h3>
        
  <ul>
  
    <li>Bug 1: unsynchronized access to <code>s.closed</code> and <code>s.err</code></li>
  
    <li>Bug 2: <code>time.Sleep</code> may keep loop running</li>
  
    <li>Bug 3: <code>loop</code> may block forever sending on <code>s.updates</code></li>
  
  </ul>

  <div class="code" >


<pre><span num="166">        select {</span>
<span num="167">        <b>case errc := &lt;-s.closing:</b></span>
<span num="168">            errc &lt;- err</span>
<span num="169">            close(s.updates)</span>
<span num="170">            return</span>
<span num="172">        <b>case &lt;-startFetch:</b></span>
<span num="173">            var fetched []Item</span>
<span num="174">            fetched, next, err = s.fetcher.Fetch()</span>
<span num="175">            if err != nil {</span>
<span num="176">                next = time.Now().Add(10 * time.Second)</span>
<span num="177">                break</span>
<span num="178">            }</span>
<span num="179">            pending = append(pending, fetched...)</span>
<span num="181">        <b>case updates &lt;- first:</b></span>
<span num="182">            pending = pending[1:]</span>
<span num="183">        }</span>
</pre>


</div>

      
      <span class="pagenumber">32</span>
      </article>
  
  
  
      <article >
      
        <h2>We can improve loop further</h2>
      
      <span class="pagenumber">33</span>
      </article>
  
  
  
      <article >
      
        <h3>Issue: Fetch may return duplicates</h3>
        
  <div class="code" >


<pre><span num="146">    var pending []Item</span>
<span num="147">    var next time.Time</span>
<span num="148">    var err error</span>
</pre>


</div>

  <div class="code" >


<pre><span num="172">        case &lt;-startFetch:</span>
<span num="173">            var fetched []Item</span>
<span num="174">            <b>fetched, next, err = s.fetcher.Fetch()</b></span>
<span num="175">            if err != nil {</span>
<span num="176">                next = time.Now().Add(10 * time.Second)</span>
<span num="177">                break</span>
<span num="178">            }</span>
<span num="179">            <b>pending = append(pending, fetched...)</b></span>
</pre>


</div>

      
      <span class="pagenumber">34</span>
      </article>
  
  
  
      <article >
      
        <h3>Fix: Filter items before adding to pending</h3>
        
  <div class="code" >


<pre><span num="192">    var pending []Item</span>
<span num="193">    var next time.Time</span>
<span num="194">    var err error</span>
<span num="195">    <b>var seen = make(map[string]bool) // set of item.GUIDs</b></span>
</pre>


</div>

  <div class="code" >


<pre><span num="220">        case &lt;-startFetch:</span>
<span num="221">            var fetched []Item</span>
<span num="222">            fetched, next, err = s.fetcher.Fetch()</span>
<span num="223">            if err != nil {</span>
<span num="224">                next = time.Now().Add(10 * time.Second)</span>
<span num="225">                break</span>
<span num="226">            }</span>
<span num="227">            for _, item := range fetched {</span>
<span num="228">                <b>if !seen[item.GUID] {</b></span>
<span num="229">                    <b>pending = append(pending, item)</b></span>
<span num="230">                    <b>seen[item.GUID] = true</b></span>
<span num="231">                <b>}</b></span>
<span num="232">            }</span>
</pre>


</div>

      
      <span class="pagenumber">35</span>
      </article>
  
  
  
      <article >
      
        <h3>Issue: Pending queue grows without bound</h3>
        
  <div class="code" >


<pre><span num="220">        case &lt;-startFetch:</span>
<span num="221">            var fetched []Item</span>
<span num="222">            fetched, next, err = s.fetcher.Fetch()</span>
<span num="223">            if err != nil {</span>
<span num="224">                next = time.Now().Add(10 * time.Second)</span>
<span num="225">                break</span>
<span num="226">            }</span>
<span num="227">            for _, item := range fetched {</span>
<span num="228">                <b>if !seen[item.GUID] {</b></span>
<span num="229">                    <b>pending = append(pending, item)</b></span>
<span num="230">                    <b>seen[item.GUID] = true</b></span>
<span num="231">                <b>}</b></span>
<span num="232">            }</span>
</pre>


</div>

      
      <span class="pagenumber">36</span>
      </article>
  
  
  
      <article >
      
        <h3>Fix: Disable fetch case when too much pending</h3>
        
  
  <div class="code"><pre>const maxPending = 10</pre></div>
  

  <div class="code" >


<pre><span num="199">        var fetchDelay time.Duration</span>
<span num="200">        if now := time.Now(); next.After(now) {</span>
<span num="201">            fetchDelay = next.Sub(now)</span>
<span num="202">        }</span>
<span num="203">        <b>var startFetch &lt;-chan time.Time</b></span>
<span num="204">        <b>if len(pending) &lt; maxPending {</b></span>
<span num="205">            <b>startFetch = time.After(fetchDelay) // enable fetch case</b></span>
<span num="206">        <b>}</b></span>
</pre>


</div>

  
  <p>
    Could instead drop older items from the head of <code>pending</code>.
  </p>
  

      
      <span class="pagenumber">37</span>
      </article>
  
  
  
      <article >
      
        <h3>Issue: Loop blocks on Fetch</h3>
        
  <div class="code" >


<pre><span num="220">        case &lt;-startFetch:</span>
<span num="221">            var fetched []Item</span>
<span num="222">            <b>fetched, next, err = s.fetcher.Fetch()</b></span>
<span num="223">            if err != nil {</span>
<span num="224">                next = time.Now().Add(10 * time.Second)</span>
<span num="225">                break</span>
<span num="226">            }</span>
<span num="227">            for _, item := range fetched {</span>
<span num="228">                if !seen[item.GUID] {</span>
<span num="229">                    pending = append(pending, item)</span>
<span num="230">                    seen[item.GUID] = true         </span>
<span num="231">                }</span>
<span num="232">            }</span>
</pre>


</div>

      
      <span class="pagenumber">38</span>
      </article>
  
  
  
      <article >
      
        <h3>Fix: Run Fetch asynchronously</h3>
        
  
  <p>
    Add a new <code>select</code> case for <code>fetchDone</code>.
  </p>
  

  
  <div class="code"><pre>type fetchResult struct{ fetched []Item; next time.Time; err error }</pre></div>
  

  <div class="code" >


<pre><span num="251">    var fetchDone chan fetchResult // if non-nil, Fetch is running</span>
</pre>


</div>

  <div class="code" >


<pre><span num="263">        var startFetch &lt;-chan time.Time</span>
<span num="264">        <b>if fetchDone == nil &amp;&amp; len(pending) &lt; maxPending {</b></span>
<span num="265">            startFetch = time.After(fetchDelay) // enable fetch case</span>
<span num="266">        }</span>
</pre>


</div>

  <div class="code" >


<pre><span num="275">        select {</span>
<span num="276">        <b>case &lt;-startFetch:</b></span>
<span num="277">            <b>fetchDone = make(chan fetchResult, 1)</b></span>
<span num="278">            go func() {</span>
<span num="279">                fetched, next, err := s.fetcher.Fetch()</span>
<span num="280">                fetchDone &lt;- fetchResult{fetched, next, err}</span>
<span num="281">            }()</span>
<span num="282">        <b>case result := &lt;-fetchDone:</b></span>
<span num="283">            <b>fetchDone = nil</b></span>
<span num="284">            // Use result.fetched, result.next, result.err</span>
</pre>


</div>

      
      <span class="pagenumber">39</span>
      </article>
  
  
  
      <article >
      
        <h3>Implemented Subscribe</h3>
        
  
  <p>
    Responsive. Cleans up. Easy to read and change.
  </p>
  

  
  <p>
    Three techniques:
  </p>
  

  <ul>
  
    <li><code>for-select</code> loop</li>
  
    <li>service channel, reply channels (<code>chan chan error</code>)</li>
  
    <li><code>nil</code> channels in <code>select</code> cases</li>
  
  </ul>

  
  <p>
    More details online, including <code>Merge</code>.
  </p>
  

<div class="image">
  <img src="advconc/gopherhat.jpg" height="200" width="158">
</div>

      
      <span class="pagenumber">40</span>
      </article>
  
  
  
      <article >
      
        <h3>Conclusion</h3>
        
  
  <p>
    Concurrent programming can be tricky.
  </p>
  

  
  <p>
    Go makes it easier:
  </p>
  

  <ul>
  
    <li>channels convey data, timer events, cancellation signals</li>
  
    <li>goroutines serialize access to local mutable state</li>
  
    <li>stack traces &amp; deadlock detector</li>
  
    <li>race detector</li>
  
  </ul>

<div class="image">
  <img src="advconc/race.png" height="200" width="750">
</div>

      
      <span class="pagenumber">41</span>
      </article>
  
  
  
      <article >
      
        <h3>Links</h3>
        
  
  <p>
    Go Concurrency Patterns (2012)
  </p>
  
<p class="link"><a href="http://talks.golang.org/2012/concurrency.slide" target="_blank">talks.golang.org/2012/concurrency.slide</a></p>
  
  <p>
    Concurrency is not parallelism
  </p>
  
<p class="link"><a href="http://golang.org/s/concurrency-is-not-parallelism" target="_blank">golang.org/s/concurrency-is-not-parallelism</a></p>
  
  <p>
    Share memory by communicating
  </p>
  
<p class="link"><a href="http://golang.org/doc/codewalk/sharemem" target="_blank">golang.org/doc/codewalk/sharemem</a></p>
  
  <p>
    Go Tour (learn Go in your browser)
  </p>
  
<p class="link"><a href="http://tour.golang.org" target="_blank">tour.golang.org</a></p>
      
      <span class="pagenumber">42</span>
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
          <div class="presenter">
            
  
  <p>
    Sameer Ajmani
  </p>
  

  
  <p>
    Google
  </p>
  
<p class="link"><a href="http://profiles.google.com/ajmani" target="_blank">http://profiles.google.com/ajmani</a></p><p class="link"><a href="http://twitter.com/Sajma" target="_blank">@Sajma</a></p><p class="link"><a href="http://golang.org" target="_blank">http://golang.org</a></p>
          </div>
        
      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

    
    <script src='/play.js'></script>
    

    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  </body>
</html>
